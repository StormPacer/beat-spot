const express = require('express');
const request = require("request");
const fetch = require("node-fetch");
const fs = require("fs");
const path = require('path');
const { base64 } = require("./public/contents.json");
const rateLimit = require("express-rate-limit");
const favicon = require("serve-favicon");

const app = express();

const limiter = rateLimit({
    windowMs: 5 * 60 * 1000,
    max: 3,
    message: "Due to the API's limits you can make only make 3 requests per 5 minutes."
})

app.use(express.static(__dirname + "/public"))

app.use(favicon(path.join(__dirname, "images", "beatspot.ico")))

app.get("/", (req, res) => {
    res.sendFile(path.join(__dirname, "public", "beatspot-home.html"))
})

app.get("/spotify", (req, res) => {
    res.sendFile(path.join(__dirname, "public", "beatspot-spotify.html"))
})

app.get("/noodle", (req, res) => {
    res.sendFile(path.join(__dirname, "public", "beatspot-noodle.html"))
})

app.get("/chroma", (req, res) => {
    res.sendFile(path.join(__dirname, "public", "beatspot-chroma.html"))
})

app.get("/cinema", (req, res) => {
    res.sendFile(path.join(__dirname, "public", "beatspot-cinema.html"))
})

app.get("/curated", (req, res) => {
    res.sendFile(path.join(__dirname, "public", "beatspot-curated.html"))
})

app.get("/ranked", (req, res) => {
    res.sendFile(path.join(__dirname, "public", "beatspot-ranked.html"))
})

app.get('/api/spotify-to-playlist', limiter, (req, res) => {
    const playlist = req.query.playlist
    const minRating = req.query.minrating
    const playlist_name = req.query.name

    let count = Number(fs.readFileSync(__dirname + "/temp/count").toString())
    count += 1
    fs.writeFileSync(__dirname + "/temp/count", count.toString())

    const playlistJSON = {
        "playlistTitle": playlist_name,
        "playlistAuthor": "BeatSpot",
        "playlistDescription": "An autogenerated playlist by BeatSpot.",
        "songs": [],
        "cover": base64
    }

    async function GetToken() {
        const data = {
            url: "https://accounts.spotify.com/api/token",
            method: "POST",
            headers: {
                "Authorization": "Basic " + (Buffer.from("51a2fa21b5d24f90b44c1f6d47e3f842:6ad809139f764ca49eeacbfac48c3398").toString("base64"))
            },
            form: {
                grant_type: 'client_credentials'
            },
            json: true
        }

        return new Promise((resolve, reject) => {
            request.post(data, function (error, response, body) {
                resolve(body.access_token)
            })
        })
    }

    async function GetPlaylist() {

        const token = await GetToken()

        const data = await fetch(`https://api.spotify.com/v1/playlists/${playlist}/tracks`, {
            method: `GET`,
            headers: {
                Authorization: `Bearer ${token}`
            }
        }).then(res => res.json())

        let promise = Promise.resolve()

        let next = null

        if (data.next !== null) next = data.next

        const maps = playlistJSON.songs

        if (next !== null) {

            const data2 = await fetch(`${next}`, {
                method: `GET`,
                headers: {
                    Authorization: `Bearer ${token}`
                }
            }).then(res => res.json())

            data.items.forEach(async (song) => {
                promise = promise.then(async function () {
                    try {
                        let title = encodeURI(song.track.name)

                        let artist = encodeURI(song.track.artists[0].name)

                        let map = await fetch(`https://api.beatsaver.com/search/text/0?q=${title}%20${artist}&sortOrder=Latest`).then(res => res.json())

                        if (map.docs.length > 1) {
                            let map_arr = []
                            map.docs.forEach(map => {
                                if (map.name.toLowerCase().includes(song.track.name.substr(0, 5).toLowerCase()) && map.stats.score > minRating && map.id.length > 3 && map.metadata.songAuthorName.toLowerCase().includes(song.track.artists[0].name.toLowerCase())) {
                                    map_arr.push(map)
                                }
                            })

                            if (map_arr.length == 0) return console.log("\x1b[33m", `No maps fit the criteria for the song ${song.track.name}`)
                            const chosen = map_arr.sort((a, b) => b.stats.score - a.stats.score)

                            maps.push(
                                {
                                    "key": chosen[0].id.toUpperCase(),
                                    "songName": chosen[0].name,
                                    "hash": chosen[0].versions[0].hash.toUpperCase(),
                                    "levelid": `custom_level_${chosen[0].versions[0].hash.toUpperCase()}`
                                },
                            )
                        }

                        else if (map.docs.length == 1) {
                            if (map.docs[0].name.toLowerCase().includes(song.track.name.substr(0, 5).toLowerCase()) && map.docs[0].stats.score > minRating && map.docs[0].metadata.songAuthorName.toLowerCase().includes(song.track.artists[0].name.toLowerCase())) {
                                maps.push(
                                    {
                                        "key": map.docs[0].id.toUpperCase(),
                                        "songName": map.docs[0].name,
                                        "hash": map.docs[0].versions[0].hash.toUpperCase(),
                                        "levelid": `custom_level_${map.docs[0].versions[0].hash.toUpperCase()}`
                                    },
                                )
                            }
                        }
                    } catch (err) {
                    }
                })
            })

            let num = 0
            data2.items.forEach(async (song) => {
                promise = promise.then(async function () {
                    num += 1
                    try {
                        let title = encodeURI(song.track.name)

                        let artist = encodeURI(song.track.artists[0].name)

                        let map = await fetch(`https://api.beatsaver.com/search/text/0?q=${title}%20${artist}&sortOrder=Latest`).then(res => res.json())

                        if (map.docs.length > 1) {
                            let map_arr = []
                            map.docs.forEach(map => {
                                if (map.name.toLowerCase().includes(song.track.name.substr(0, 5).toLowerCase()) && map.stats.score > minRating && map.id.length > 3 && map.metadata.songAuthorName.toLowerCase().includes(song.track.artists[0].name.toLowerCase())) {
                                    map_arr.push(map)
                                }
                            })

                            if (map_arr.length == 0) return console.log("\x1b[33m", `No maps fit the criteria for the song ${song.track.name}`)
                            const chosen = map_arr.sort((a, b) => b.stats.score - a.stats.score)

                            maps.push(
                                {
                                    "key": chosen[0].id.toUpperCase(),
                                    "songName": chosen[0].name,
                                    "hash": chosen[0].versions[0].hash.toUpperCase(),
                                    "levelid": `custom_level_${chosen[0].versions[0].hash.toUpperCase()}`
                                },
                            )
                        }

                        else if (map.docs.length == 1) {
                            if (map.docs[0].name.toLowerCase().includes(song.track.name.substr(0, 5).toLowerCase()) && map.docs[0].stats.score > minRating && map.docs[0].metadata.songAuthorName.toLowerCase().includes(song.track.artists[0].name.toLowerCase())) {
                                maps.push(
                                    {
                                        "key": map.docs[0].id.toUpperCase(),
                                        "songName": map.docs[0].name,
                                        "hash": map.docs[0].versions[0].hash.toUpperCase(),
                                        "levelid": `custom_level_${map.docs[0].versions[0].hash.toUpperCase()}`
                                    },
                                )
                            }
                        }

                        if (num == data2.items.length) {
                            fs.writeFileSync(__dirname + `/temp/${playlist_name}.bplist`, JSON.stringify(playlistJSON))
                            res.download(__dirname + `/temp/${playlist_name}.bplist`)
                            setTimeout(() => fs.unlinkSync(__dirname + `/temp/${playlist_name}.bplist`), 2000)
                            return
                        }
                    } catch (err) {
                    }
                })
            })
        } else if (data.next == null) {
            let num = 0
            data.items.forEach(async (song) => {
                promise = promise.then(async function () {
                    num += 1
                    try {

                        let title = encodeURI(song.track.name)

                        let artist = encodeURI(song.track.artists[0].name)

                        let map = await fetch(`https://api.beatsaver.com/search/text/0?q=${title}%20${artist}&sortOrder=Latest`).then(res => res.json())

                        if (map.docs.length > 1) {
                            let map_arr = []
                            map.docs.forEach(map => {
                                if (map.name.toLowerCase().includes(song.track.name.substr(0, 5).toLowerCase()) && map.stats.score > minRating && map.id.length > 3 && map.metadata.songAuthorName.toLowerCase().includes(song.track.artists[0].name.toLowerCase())) {
                                    map_arr.push(map)
                                }
                            })

                            if (map_arr.length == 0) return
                            const chosen = map_arr.sort((a, b) => b.stats.score - a.stats.score)

                            maps.push(
                                {
                                    "key": chosen[0].id.toUpperCase(),
                                    "songName": chosen[0].name,
                                    "hash": chosen[0].versions[0].hash.toUpperCase(),
                                    "levelid": `custom_level_${chosen[0].versions[0].hash.toUpperCase()}`
                                }
                            )
                        }

                        else if (map.docs.length == 1) {
                            if (map.docs[0].name.toLowerCase().includes(song.track.name.substr(0, 5).toLowerCase()) && map.docs[0].stats.score > minRating && map.docs[0].metadata.songAuthorName.toLowerCase().includes(song.track.artists[0].name.toLowerCase())) {
                                maps.push(
                                    {
                                        "key": map.docs[0].id.toUpperCase(),
                                        "songName": map.docs[0].name,
                                        "hash": map.docs[0].versions[0].hash.toUpperCase(),
                                        "levelid": `custom_level_${map.docs[0].versions[0].hash.toUpperCase()}`
                                    }
                                )
                            }
                        }

                        if (num == data.items.length) {
                            fs.writeFileSync(__dirname + `/temp/${playlist_name}.bplist`, JSON.stringify(playlistJSON))
                            res.download(__dirname + `/temp/${playlist_name}.bplist`)
                            setTimeout(() => fs.unlinkSync(__dirname + `/temp/${playlist_name}.bplist`), 2000)
                            return
                        }

                    } catch (err) {
                    }
                })
                return new Promise(function (resolve) {
                    setTimeout(resolve, 10)
                })
            })
        }
    }

    GetPlaylist()
});

app.get('/api/noodle', (req, res) => {
    const minRating = req.query.minrating
    const playlist_name = req.query.name

    let count = Number(fs.readFileSync(__dirname + "/temp/count").toString())
    count += 1
    fs.writeFileSync(__dirname + "/temp/count", count.toString())

    const playlistJSON = {
        "playlistTitle": playlist_name,
        "playlistAuthor": "BeatSpot",
        "playlistDescription": "An autogenerated playlist by BeatSpot.",
        "songs": [],
        "cover": base64
    }

    let promise = Promise.resolve()

    const maps = playlistJSON.songs

    promise = promise.then(async function () {
        for (let x = 0; x < 200; x++) {
            try {
                let map = await fetch(`https://api.beatsaver.com/search/text/${x}?noodle=true&sortOrder=Latest`).then(res => res.json())

                if (!map.docs[1]) {
                    fs.writeFileSync(__dirname + `/temp/${playlist_name}.bplist`, JSON.stringify(playlistJSON))
                    res.download(__dirname + `/temp/${playlist_name}.bplist`)
                    setTimeout(() => fs.unlinkSync(__dirname + `/temp/${playlist_name}.bplist`), 2000)
                    return
                }

                for (i in map.docs) {
                    if (map.docs[i].stats.score > minRating) {
                        maps.push(
                            {
                                "key": map.docs[i].id.toUpperCase(),
                                "songName": map.docs[i].name,
                                "hash": map.docs[i].versions[0].hash.toUpperCase(),
                                "levelid": `custom_level_${map.docs[i].versions[0].hash.toUpperCase()}`
                            },
                        )
                    }
                }

            } catch (err) {
                console.log(err)
            }
        }
    })
    return new Promise(function (resolve) {
        setTimeout(resolve, 10)
    })
});

app.get("/api/chroma", (req, res) => {
    const minRating = req.query.minrating
    const playlist_name = req.query.name

    let count = Number(fs.readFileSync(__dirname + "/temp/count").toString())
    count += 1
    fs.writeFileSync(__dirname + "/temp/count", count.toString())
    
    const playlistJSON = {
        "playlistTitle": playlist_name,
        "playlistAuthor": "BeatSpot",
        "playlistDescription": "An autogenerated playlist by BeatSpot.",
        "songs": [],
        "cover": base64
    }

    let promise = Promise.resolve()

    const maps = playlistJSON.songs

    promise = promise.then(async function () {
        for (let x = 0; x < 200; x++) {
            try {
                let map = await fetch(`https://api.beatsaver.com/search/text/${x}?chroma=true&sortOrder=Latest`).then(res => res.json())

                if (!map.docs[1]) {
                    fs.writeFileSync(__dirname + `/temp/${playlist_name}.bplist`, JSON.stringify(playlistJSON))
                    res.download(__dirname + `/temp/${playlist_name}.bplist`)
                    setTimeout(() => fs.unlinkSync(__dirname + `/temp/${playlist_name}.bplist`), 2000)
                    return
                }

                for (i in map.docs) {
                    if (map.docs[i].stats.score > minRating) {
                        maps.push(
                            {
                                "key": map.docs[i].id.toUpperCase(),
                                "songName": map.docs[i].name,
                                "hash": map.docs[i].versions[0].hash.toUpperCase(),
                                "levelid": `custom_level_${map.docs[i].versions[0].hash.toUpperCase()}`
                            },
                        )
                    }
                }

            } catch (err) {
                console.log(err)
            }
        }
    })
    return new Promise(function (resolve) {
        setTimeout(resolve, 10)
    })
})

app.get("/api/cinema", (req, res) => {
    const minRating = req.query.minrating
    const playlist_name = req.query.name

    let count = Number(fs.readFileSync(__dirname + "/temp/count").toString())
    count += 1
    fs.writeFileSync(__dirname + "/temp/count", count.toString())

    const playlistJSON = {
        "playlistTitle": playlist_name,
        "playlistAuthor": "BeatSpot",
        "playlistDescription": "An autogenerated playlist by BeatSpot.",
        "songs": [],
        "cover": base64
    }

    let promise = Promise.resolve()

    const maps = playlistJSON.songs

    promise = promise.then(async function () {
        for (let x = 0; x < 200; x++) {
            try {
                let map = await fetch(`https://api.beatsaver.com/search/text/${x}?cinema=true&sortOrder=Latest`).then(res => res.json())

                if (!map.docs[1]) {
                    fs.writeFileSync(__dirname + `/temp/${playlist_name}.bplist`, JSON.stringify(playlistJSON))
                    res.download(__dirname + `/temp/${playlist_name}.bplist`)
                    setTimeout(() => fs.unlinkSync(__dirname + `/temp/${playlist_name}.bplist`), 2000)
                    return
                }

                for (i in map.docs) {
                    if (map.docs[i].stats.score > minRating) {
                        maps.push(
                            {
                                "key": map.docs[i].id.toUpperCase(),
                                "songName": map.docs[i].name,
                                "hash": map.docs[i].versions[0].hash.toUpperCase(),
                                "levelid": `custom_level_${map.docs[i].versions[0].hash.toUpperCase()}`
                            },
                        )
                    }
                }

            } catch (err) {
                console.log(err)
            }
        }
    })
    return new Promise(function (resolve) {
        setTimeout(resolve, 10)
    })
})

app.get("/api/curated", (req, res) => {
    const minRating = req.query.minrating
    const playlist_name = req.query.name

    let count = Number(fs.readFileSync(__dirname + "/temp/count").toString())
    count += 1
    fs.writeFileSync(__dirname + "/temp/count", count.toString())

    const playlistJSON = {
        "playlistTitle": playlist_name,
        "playlistAuthor": "BeatSpot",
        "playlistDescription": "An autogenerated playlist by BeatSpot.",
        "songs": [],
        "cover": base64
    }

    let promise = Promise.resolve()

    const maps = playlistJSON.songs

    promise = promise.then(async function () {
        for (let x = 0; x < 200; x++) {
            try {
                let map = await fetch(`https://api.beatsaver.com/search/text/${x}?curated=true&sortOrder=Latest`).then(res => res.json())

                if (!map.docs[1]) {
                    fs.writeFileSync(__dirname + `/temp/${playlist_name}.bplist`, JSON.stringify(playlistJSON))
                    res.download(__dirname + `/temp/${playlist_name}.bplist`)
                    setTimeout(() => fs.unlinkSync(__dirname + `/temp/${playlist_name}.bplist`), 2000)
                    return
                }

                for (i in map.docs) {
                    if (map.docs[i].stats.score > minRating) {
                        maps.push(
                            {
                                "key": map.docs[i].id.toUpperCase(),
                                "songName": map.docs[i].name,
                                "hash": map.docs[i].versions[0].hash.toUpperCase(),
                                "levelid": `custom_level_${map.docs[i].versions[0].hash.toUpperCase()}`
                            },
                        )
                    }
                }

            } catch (err) {
                console.log(err)
            }
        }
    })
    return new Promise(function (resolve) {
        setTimeout(resolve, 10)
    })
})

app.get("/api/ranked", (req, res) => {
    const minRating = req.query.minrating
    const playlist_name = req.query.name

    let count = Number(fs.readFileSync(__dirname + "/temp/count").toString())
    count += 1
    fs.writeFileSync(__dirname + "/temp/count", count.toString())

    const playlistJSON = {
        "playlistTitle": playlist_name,
        "playlistAuthor": "BeatSpot",
        "playlistDescription": "An autogenerated playlist by BeatSpot.",
        "songs": [],
        "cover": base64
    }

    let promise = Promise.resolve()

    const maps = playlistJSON.songs

    promise = promise.then(async function () {
        for (let x = 0; x < 200; x++) {
            try {
                let map = await fetch(`https://api.beatsaver.com/search/text/${x}?ranked=true&sortOrder=Latest`).then(res => res.json())

                if (!map.docs[1]) {
                    fs.writeFileSync(__dirname + `/temp/${playlist_name}.bplist`, JSON.stringify(playlistJSON))
                    res.download(__dirname + `/temp/${playlist_name}.bplist`)
                    setTimeout(() => fs.unlinkSync(__dirname + `/temp/${playlist_name}.bplist`), 2000)
                    return
                }

                for (i in map.docs) {
                    if (map.docs[i].stats.score > minRating) {
                        maps.push(
                            {
                                "key": map.docs[i].id.toUpperCase(),
                                "songName": map.docs[i].name,
                                "hash": map.docs[i].versions[0].hash.toUpperCase(),
                                "levelid": `custom_level_${map.docs[i].versions[0].hash.toUpperCase()}`
                            },
                        )
                    }
                }

            } catch (err) {
                console.log(err)
            }
        }
    })
    return new Promise(function (resolve) {
        setTimeout(resolve, 10)
    })
})

app.listen(3000, () => {
    console.log(`Listening on port 3000`)
});